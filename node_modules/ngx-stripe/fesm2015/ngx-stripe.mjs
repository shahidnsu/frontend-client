import * as i3 from '@angular/common';
import { isPlatformBrowser, isPlatformServer, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Directive, InjectionToken, PLATFORM_ID, Injectable, Inject, EventEmitter, Input, Output, TemplateRef, Component, Optional, ContentChild, ViewChild, NgModule, inject } from '@angular/core';
import { __awaiter } from 'tslib';
import { BehaviorSubject, from, lastValueFrom } from 'rxjs';
import { filter, first, map, switchMap } from 'rxjs/operators';

class NgxStripeElementLoadingTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgxStripeElementLoadingTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeElementLoadingTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NgxStripeElementLoadingTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.0", type: NgxStripeElementLoadingTemplateDirective, isStandalone: true, selector: "[ngxStripeLoadingTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeElementLoadingTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxStripeLoadingTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

const STRIPE_PUBLISHABLE_KEY = new InjectionToken('Stripe Publishable Key');
const STRIPE_OPTIONS = new InjectionToken('Stripe Options');
const NGX_STRIPE_VERSION = new InjectionToken('NGX_STRIPE_VERSION');

class StripeInstance {
    constructor(version, loader, window, key, options) {
        this.version = version;
        this.loader = loader;
        this.window = window;
        this.key = key;
        this.options = options;
        this.stripe$ = new BehaviorSubject(undefined);
        this.stripe = this.stripe$.asObservable().pipe(filter((stripe) => Boolean(stripe)));
        this.loader
            .asStream()
            .pipe(filter((status) => status.loaded === true), first(), map(() => this.window.getNativeWindow().Stripe))
            .subscribe((stripeInstance) => {
            const stripe = this.options
                ? stripeInstance(this.key, this.options)
                : stripeInstance(this.key);
            stripe.registerAppInfo(this.getNgxStripeAppInfo(this.version));
            this.stripe$.next(stripe);
        });
    }
    getInstance() {
        return this.stripe$.getValue();
    }
    elements(options) {
        return this.stripe.pipe(map((stripe) => stripe.elements(options)), first());
    }
    redirectToCheckout(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.redirectToCheckout(options))), first());
    }
    confirmPayment(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPayment(options))), first());
    }
    confirmAcssDebitPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAcssDebitPayment(clientSecret, data, options))), first());
    }
    confirmUsBankAccountPayment(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmUsBankAccountPayment(clientSecret, data))), first());
    }
    confirmAlipayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAlipayPayment(clientSecret, data, options))), first());
    }
    confirmAuBecsDebitPayment(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAuBecsDebitPayment(clientSecret, data))), first());
    }
    confirmBancontactPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmBancontactPayment(clientSecret, data, options))), first());
    }
    confirmBoletoPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmBoletoPayment(clientSecret, data, options))), first());
    }
    confirmCardPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmCardPayment(clientSecret, data, options))), first());
    }
    confirmCustomerBalancePayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmCustomerBalancePayment(clientSecret, data, options))), first());
    }
    confirmEpsPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmEpsPayment(clientSecret, data, options))), first());
    }
    confirmFpxPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmFpxPayment(clientSecret, data, options))), first());
    }
    confirmGiropayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmGiropayPayment(clientSecret, data, options))), first());
    }
    confirmGrabPayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmGrabPayPayment(clientSecret, data, options))), first());
    }
    confirmIdealPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmIdealPayment(clientSecret, data, options))), first());
    }
    confirmKlarnaPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmKlarnaPayment(clientSecret, data, options))), first());
    }
    confirmKonbiniPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmKonbiniPayment(clientSecret, data, options))), first());
    }
    confirmOxxoPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmOxxoPayment(clientSecret, data, options))), first());
    }
    confirmP24Payment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmP24Payment(clientSecret, data, options))), first());
    }
    confirmPayNowPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPayNowPayment(clientSecret, data, options))), first());
    }
    confirmPayPalPayment(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPayPalPayment(clientSecret, data))), first());
    }
    confirmPixPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPixPayment(clientSecret, data, options))), first());
    }
    confirmPromptPayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPromptPayPayment(clientSecret, data, options))), first());
    }
    confirmSepaDebitPayment(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSepaDebitPayment(clientSecret, data))), first());
    }
    confirmSofortPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSofortPayment(clientSecret, data, options))), first());
    }
    confirmWechatPayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmWechatPayPayment(clientSecret, data, options))), first());
    }
    handleCardAction(clientSecret) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.handleCardAction(clientSecret))), first());
    }
    verifyMicrodepositsForPayment(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.verifyMicrodepositsForPayment(clientSecret, data))), first());
    }
    createRadarSession() {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.createRadarSession())), first());
    }
    collectBankAccountForPayment(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.collectBankAccountForPayment(options))), first());
    }
    createPaymentMethod(paymentMethodData) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.createPaymentMethod(paymentMethodData))), first());
    }
    retrievePaymentIntent(clientSecret) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.retrievePaymentIntent(clientSecret))), first());
    }
    confirmSetup(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSetup(options))), first());
    }
    confirmAcssDebitSetup(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAcssDebitSetup(clientSecret, data, options))), first());
    }
    confirmUsBankAccountSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmUsBankAccountSetup(clientSecret, data))), first());
    }
    confirmAuBecsDebitSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAuBecsDebitSetup(clientSecret, data))), first());
    }
    confirmBacsDebitSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmBacsDebitSetup(clientSecret, data))), first());
    }
    confirmBancontactSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmBancontactSetup(clientSecret, data))), first());
    }
    confirmCardSetup(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmCardSetup(clientSecret, data, options))), first());
    }
    confirmIdealSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmIdealSetup(clientSecret, data))), first());
    }
    confirmPayPalSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPayPalSetup(clientSecret, data))), first());
    }
    confirmSepaDebitSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSepaDebitSetup(clientSecret, data))), first());
    }
    confirmSofortSetup(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSofortSetup(clientSecret, data, options))), first());
    }
    confirmAffirmPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAffirmPayment(clientSecret, data, options))), first());
    }
    confirmAfterpayClearpayPayment(clientSecret, data, options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmAfterpayClearpayPayment(clientSecret, data, options))), first());
    }
    verifyMicrodepositsForSetup(clientSecret, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.verifyMicrodepositsForSetup(clientSecret, data))), first());
    }
    collectBankAccountForSetup(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.collectBankAccountForSetup(options))), first());
    }
    retrieveSetupIntent(clientSecret) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.retrieveSetupIntent(clientSecret))), first());
    }
    processOrder(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.processOrder(options))), first());
    }
    retrieveOrder(clientSecret) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.retrieveOrder(clientSecret))), first());
    }
    paymentRequest(options) {
        const stripe = this.getInstance();
        return stripe.paymentRequest(options);
    }
    createToken(tokenType, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.createToken(tokenType, data))), first());
    }
    createSource(a, b) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.createSource(a, b))), first());
    }
    retrieveSource(source) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.retrieveSource(source))), first());
    }
    verifyIdentity(clientSecret) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.verifyIdentity(clientSecret))), first());
    }
    collectFinancialConnectionsAccounts(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.collectFinancialConnectionsAccounts(options))), first());
    }
    collectBankAccountToken(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.collectBankAccountToken(options))), first());
    }
    createEphemeralKeyNonce(options) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.createEphemeralKeyNonce(options))), first());
    }
    /**
     * @deprecated
     */
    handleCardPayment(clientSecret, element, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.handleCardPayment(clientSecret, element, data))), first());
    }
    /**
     * @deprecated
     */
    confirmPaymentIntent(clientSecret, element, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmPaymentIntent(clientSecret, element, data))), first());
    }
    /**
     * @deprecated
     */
    handleCardSetup(clientSecret, element, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.handleCardSetup(clientSecret, element, data))), first());
    }
    /**
     * @deprecated
     */
    confirmSetupIntent(clientSecret, element, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.confirmSetupIntent(clientSecret, element, data))), first());
    }
    /**
     * @deprecated
     */
    handleFpxPayment(clientSecret, element, data) {
        return this.stripe.pipe(switchMap((stripe) => from(stripe.handleFpxPayment(clientSecret, element, data))), first());
    }
    getNgxStripeAppInfo(version) {
        return {
            name: 'ngx-stripe',
            url: 'https://ngx-stripe.dev',
            partner_id: 'pp_partner_JR4l1rmvUoPP4V',
            version
        };
    }
}

class WindowRef {
    constructor(platformId) {
        this.platformId = platformId;
    }
    getNativeWindow() {
        if (isPlatformBrowser(this.platformId)) {
            return window;
        }
        return {};
    }
}
WindowRef.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: WindowRef, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
WindowRef.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: WindowRef });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: WindowRef, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }];
    } });

class DocumentRef {
    constructor(platformId) {
        this.platformId = platformId;
    }
    getNativeDocument() {
        if (isPlatformBrowser(this.platformId)) {
            return document;
        }
        return {};
    }
}
DocumentRef.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: DocumentRef, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
DocumentRef.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: DocumentRef });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: DocumentRef, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }];
    } });

class LazyStripeAPILoader {
    constructor(platformId, window, document) {
        this.platformId = platformId;
        this.window = window;
        this.document = document;
        this.status = new BehaviorSubject({
            error: false,
            loaded: false,
            loading: false
        });
    }
    asStream() {
        this.load();
        return this.status.asObservable();
    }
    isReady() {
        return this.status.getValue().loaded;
    }
    load() {
        if (isPlatformServer(this.platformId)) {
            return;
        }
        const status = this.status.getValue();
        if (this.window.getNativeWindow().hasOwnProperty('Stripe')) {
            this.status.next({
                error: false,
                loaded: true,
                loading: false
            });
        }
        else if (!status.loaded && !status.loading) {
            this.status.next(Object.assign(Object.assign({}, status), { loading: true }));
            const script = this.document.getNativeDocument().createElement('script');
            script.type = 'text/javascript';
            script.async = true;
            script.defer = true;
            script.src = 'https://js.stripe.com/v3/';
            script.onload = () => {
                this.status.next({
                    error: false,
                    loaded: true,
                    loading: false
                });
            };
            script.onerror = () => {
                this.status.next({
                    error: true,
                    loaded: false,
                    loading: false
                });
            };
            this.document.getNativeDocument().body.appendChild(script);
        }
    }
}
LazyStripeAPILoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: LazyStripeAPILoader, deps: [{ token: PLATFORM_ID }, { token: WindowRef }, { token: DocumentRef }], target: i0.ɵɵFactoryTarget.Injectable });
LazyStripeAPILoader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: LazyStripeAPILoader });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: LazyStripeAPILoader, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: WindowRef }, { type: DocumentRef }];
    } });

class StripeService {
    constructor(version, key, options, loader, window) {
        this.version = version;
        this.key = key;
        this.options = options;
        this.loader = loader;
        this.window = window;
        if (key) {
            this.stripe = new StripeInstance(this.version, this.loader, this.window, key, options);
        }
    }
    getStripeReference() {
        return this.loader.asStream().pipe(filter((status) => status.loaded === true), map(() => this.window.getNativeWindow().Stripe));
    }
    getInstance() {
        return this.stripe.getInstance();
    }
    setKey(key, options) {
        return this.changeKey(key, options);
    }
    changeKey(key, options) {
        this.stripe = new StripeInstance(this.version, this.loader, this.window, key, options);
        return this.stripe;
    }
    elements(options) {
        return this.stripe.elements(options);
    }
    redirectToCheckout(options) {
        return this.stripe.redirectToCheckout(options);
    }
    confirmPayment(options) {
        return this.stripe.confirmPayment(options);
    }
    confirmAcssDebitPayment(clientSecret, data, options) {
        return this.stripe.confirmAcssDebitPayment(clientSecret, data, options);
    }
    confirmUsBankAccountPayment(clientSecret, data) {
        return this.stripe.confirmUsBankAccountPayment(clientSecret, data);
    }
    confirmAlipayPayment(clientSecret, data, options) {
        return this.stripe.confirmAlipayPayment(clientSecret, data, options);
    }
    confirmAuBecsDebitPayment(clientSecret, data) {
        return this.stripe.confirmAuBecsDebitPayment(clientSecret, data);
    }
    confirmBancontactPayment(clientSecret, data, options) {
        return this.stripe.confirmBancontactPayment(clientSecret, data, options);
    }
    confirmBoletoPayment(clientSecret, data, options) {
        return this.stripe.confirmBoletoPayment(clientSecret, data, options);
    }
    confirmCardPayment(clientSecret, data, options) {
        return this.stripe.confirmCardPayment(clientSecret, data, options);
    }
    confirmCustomerBalancePayment(clientSecret, data, options) {
        return this.stripe.confirmCustomerBalancePayment(clientSecret, data, options);
    }
    confirmEpsPayment(clientSecret, data, options) {
        return this.stripe.confirmEpsPayment(clientSecret, data, options);
    }
    confirmFpxPayment(clientSecret, data, options) {
        return this.stripe.confirmFpxPayment(clientSecret, data, options);
    }
    confirmGiropayPayment(clientSecret, data, options) {
        return this.stripe.confirmGiropayPayment(clientSecret, data, options);
    }
    confirmGrabPayPayment(clientSecret, data, options) {
        return this.stripe.confirmGrabPayPayment(clientSecret, data, options);
    }
    confirmIdealPayment(clientSecret, data, options) {
        return this.stripe.confirmIdealPayment(clientSecret, data, options);
    }
    confirmKlarnaPayment(clientSecret, data, options) {
        return this.stripe.confirmKlarnaPayment(clientSecret, data, options);
    }
    confirmKonbiniPayment(clientSecret, data, options) {
        return this.stripe.confirmKonbiniPayment(clientSecret, data, options);
    }
    confirmOxxoPayment(clientSecret, data, options) {
        return this.stripe.confirmOxxoPayment(clientSecret, data, options);
    }
    confirmP24Payment(clientSecret, data, options) {
        return this.stripe.confirmP24Payment(clientSecret, data, options);
    }
    confirmPayNowPayment(clientSecret, data, options) {
        return this.stripe.confirmPayNowPayment(clientSecret, data, options);
    }
    confirmPayPalPayment(clientSecret, data) {
        return this.stripe.confirmPayPalPayment(clientSecret, data);
    }
    confirmPixPayment(clientSecret, data, options) {
        return this.stripe.confirmPixPayment(clientSecret, data, options);
    }
    confirmPromptPayPayment(clientSecret, data, options) {
        return this.stripe.confirmPromptPayPayment(clientSecret, data, options);
    }
    confirmSepaDebitPayment(clientSecret, data) {
        return this.stripe.confirmSepaDebitPayment(clientSecret, data);
    }
    confirmSofortPayment(clientSecret, data, options) {
        return this.stripe.confirmSofortPayment(clientSecret, data, options);
    }
    confirmWechatPayPayment(clientSecret, data, options) {
        return this.stripe.confirmWechatPayPayment(clientSecret, data, options);
    }
    handleCardAction(clientSecret) {
        return this.stripe.handleCardAction(clientSecret);
    }
    verifyMicrodepositsForPayment(clientSecret, data) {
        return this.stripe.verifyMicrodepositsForPayment(clientSecret, data);
    }
    createRadarSession() {
        return this.stripe.createRadarSession();
    }
    collectBankAccountForPayment(options) {
        return this.stripe.collectBankAccountForPayment(options);
    }
    createPaymentMethod(paymentMethodData) {
        return this.stripe.createPaymentMethod(paymentMethodData);
    }
    retrievePaymentIntent(clientSecret) {
        return this.stripe.retrievePaymentIntent(clientSecret);
    }
    confirmSetup(options) {
        return this.stripe.confirmSetup(options);
    }
    confirmAcssDebitSetup(clientSecret, data, options) {
        return this.stripe.confirmAcssDebitSetup(clientSecret, data, options);
    }
    confirmUsBankAccountSetup(clientSecret, data) {
        return this.stripe.confirmUsBankAccountSetup(clientSecret, data);
    }
    confirmAuBecsDebitSetup(clientSecret, data) {
        return this.stripe.confirmAuBecsDebitSetup(clientSecret, data);
    }
    confirmBacsDebitSetup(clientSecret, data) {
        return this.stripe.confirmBacsDebitSetup(clientSecret, data);
    }
    confirmBancontactSetup(clientSecret, data) {
        return this.stripe.confirmBancontactSetup(clientSecret, data);
    }
    confirmCardSetup(clientSecret, data, options) {
        return this.stripe.confirmCardSetup(clientSecret, data, options);
    }
    confirmIdealSetup(clientSecret, data) {
        return this.stripe.confirmIdealSetup(clientSecret, data);
    }
    confirmPayPalSetup(clientSecret, data) {
        return this.stripe.confirmPayPalSetup(clientSecret, data);
    }
    confirmSepaDebitSetup(clientSecret, data) {
        return this.stripe.confirmSepaDebitSetup(clientSecret, data);
    }
    confirmSofortSetup(clientSecret, data, options) {
        return this.stripe.confirmSofortSetup(clientSecret, data, options);
    }
    confirmAffirmPayment(clientSecret, data, options) {
        return this.stripe.confirmAffirmPayment(clientSecret, data, options);
    }
    confirmAfterpayClearpayPayment(clientSecret, data, options) {
        return this.stripe.confirmAfterpayClearpayPayment(clientSecret, data, options);
    }
    verifyMicrodepositsForSetup(clientSecret, data) {
        return this.stripe.verifyMicrodepositsForSetup(clientSecret, data);
    }
    collectBankAccountForSetup(options) {
        return this.stripe.collectBankAccountForSetup(options);
    }
    retrieveSetupIntent(clientSecret) {
        return this.stripe.retrieveSetupIntent(clientSecret);
    }
    processOrder(options) {
        return this.stripe.processOrder(options);
    }
    retrieveOrder(clientSecret) {
        return this.stripe.retrieveOrder(clientSecret);
    }
    paymentRequest(options) {
        return this.stripe.paymentRequest(options);
    }
    createToken(tokenType, data) {
        return this.stripe.createToken(tokenType, data);
    }
    createSource(a, b) {
        return this.stripe.createSource(a, b);
    }
    retrieveSource(source) {
        return this.stripe.retrieveSource(source);
    }
    verifyIdentity(clientSecret) {
        return this.stripe.verifyIdentity(clientSecret);
    }
    collectFinancialConnectionsAccounts(options) {
        return this.stripe.collectFinancialConnectionsAccounts(options);
    }
    collectBankAccountToken(options) {
        return this.stripe.collectBankAccountToken(options);
    }
    createEphemeralKeyNonce(options) {
        return this.stripe.createEphemeralKeyNonce(options);
    }
    /**
     * @deprecated
     */
    handleCardPayment(clientSecret, element, data) {
        return this.stripe.handleCardPayment(clientSecret, element, data);
    }
    /**
     * @deprecated
     */
    confirmPaymentIntent(clientSecret, element, data) {
        return this.stripe.confirmPaymentIntent(clientSecret, element, data);
    }
    /**
     * @deprecated
     */
    handleCardSetup(clientSecret, element, data) {
        return this.stripe.handleCardSetup(clientSecret, element, data);
    }
    /**
     * @deprecated
     */
    confirmSetupIntent(clientSecret, element, data) {
        return this.stripe.confirmSetupIntent(clientSecret, element, data);
    }
    /**
     * @deprecated
     */
    handleFpxPayment(clientSecret, element, data) {
        return this.stripe.handleFpxPayment(clientSecret, element, data);
    }
}
StripeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeService, deps: [{ token: NGX_STRIPE_VERSION }, { token: STRIPE_PUBLISHABLE_KEY }, { token: STRIPE_OPTIONS }, { token: LazyStripeAPILoader }, { token: WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
StripeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [NGX_STRIPE_VERSION]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [STRIPE_PUBLISHABLE_KEY]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [STRIPE_OPTIONS]
                    }] }, { type: LazyStripeAPILoader }, { type: WindowRef }];
    } });

class StripeElementsService {
    constructor(stripeService) {
        this.stripeService = stripeService;
    }
    elements(stripe, options = {}) {
        if (stripe) {
            if (Object.keys(options).length > 0) {
                return stripe.elements(options);
            }
            return stripe.elements();
        }
        else {
            if (Object.keys(options).length > 0) {
                return this.stripeService.elements(options);
            }
            return this.stripeService.elements();
        }
    }
    paymentRequest(stripe, options) {
        return stripe ? stripe.paymentRequest(options) : this.stripeService.paymentRequest(options);
    }
    mergeOptions(options, containerClass) {
        if (!containerClass || (options && options.classes)) {
            return options || {};
        }
        if (!options || !options.classes) {
            return Object.assign(Object.assign({}, (options || {})), { classes: {
                    base: containerClass,
                    complete: `${containerClass}--complete`,
                    empty: `${containerClass}--empty`,
                    focus: `${containerClass}--focus`,
                    invalid: `${containerClass}--invalid`,
                    webkitAutoFill: `${containerClass}--webkit-autoFill`
                } });
        }
        return options || {};
    }
}
StripeElementsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeElementsService, deps: [{ token: StripeService }], target: i0.ɵɵFactoryTarget.Injectable });
StripeElementsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeElementsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeElementsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: StripeService }]; } });

class StripeElementsDirective {
    constructor(stripeElementsService) {
        this.stripeElementsService = stripeElementsService;
        this.elements = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            const elementsOptions = this.elementsOptions;
            const stripe = this.stripe;
            if (changes.elementsOptions || changes.stripe || !this._elements) {
                this._elements = yield lastValueFrom(this.stripeElementsService.elements(stripe, elementsOptions));
                this.elements.emit(this._elements);
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state === 'notready') {
                this.state = 'starting';
                this._elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.elements.emit(this._elements);
                this.state = 'ready';
            }
        });
    }
}
StripeElementsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeElementsDirective, deps: [{ token: StripeElementsService }], target: i0.ɵɵFactoryTarget.Directive });
StripeElementsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.0", type: StripeElementsDirective, isStandalone: true, selector: "ngx-stripe-elements,[ngxStripeElements]", inputs: { elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { elements: "elements" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeElementsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngx-stripe-elements,[ngxStripeElements]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: StripeElementsService }]; }, propDecorators: { elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], elements: [{
                type: Output
            }] } });

class StripeAddressComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.loaderror = new EventEmitter();
        this.loaderstart = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        return this.element.update(options);
    }
    getValue() {
        const address = this.elements.getElement('address');
        return address.getValue();
    }
    /**
     * @deprecated
     */
    getAddressElement() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('address', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.on('loaderror', () => this.loaderror.emit());
        this.element.on('loaderstart', () => this.loaderstart.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeAddressComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAddressComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeAddressComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeAddressComponent, isStandalone: true, selector: "ngx-stripe-address", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape", loaderror: "loaderror", loaderstart: "loaderstart" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAddressComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-address',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }], loaderror: [{
                type: Output
            }], loaderstart: [{
                type: Output
            }] } });

class StripeAffirmMessageComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.ready = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getAffirmMessage() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('affirmMessage', options);
        this.element.on('ready', () => this.ready.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeAffirmMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAffirmMessageComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeAffirmMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeAffirmMessageComponent, isStandalone: true, selector: "ngx-stripe-affirm-message", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", ready: "ready" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAffirmMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-affirm-message',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], ready: [{
                type: Output
            }] } });

class StripeAfterpayClearpayMessageComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.ready = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getAfterpayClearpayMessage() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('afterpayClearpayMessage', options);
        this.element.on('ready', () => this.ready.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeAfterpayClearpayMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAfterpayClearpayMessageComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeAfterpayClearpayMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeAfterpayClearpayMessageComponent, isStandalone: true, selector: "ngx-stripe-afterpay-clearpay-message", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", ready: "ready" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAfterpayClearpayMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-afterpay-clearpay-message',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], ready: [{
                type: Output
            }] } });

class StripeCardComponent {
    constructor(cdr, stripeElementsService, elementsProvider) {
        this.cdr = cdr;
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getCard() {
        return this.element;
    }
    createElement(options = {}) {
        this.state = 'ready';
        this.cdr.detectChanges();
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('card', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeCardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeCardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeCardComponent, isStandalone: true, selector: "ngx-stripe-card", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-card',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeCardGroupDirective {
    constructor(stripeElementsService) {
        this.stripeElementsService = stripeElementsService;
        this.elements = new EventEmitter();
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            const elementsOptions = this.elementsOptions;
            const stripe = this.stripe;
            if (changes.elementsOptions || changes.stripe || !this._elements) {
                this._elements = yield lastValueFrom(this.stripeElementsService.elements(stripe, elementsOptions));
                this.elements.emit(this._elements);
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state === 'notready') {
                this.state = 'starting';
                this._elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.elements.emit(this._elements);
                this.state = 'ready';
            }
        });
    }
}
StripeCardGroupDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardGroupDirective, deps: [{ token: StripeElementsService }], target: i0.ɵɵFactoryTarget.Directive });
StripeCardGroupDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.0", type: StripeCardGroupDirective, isStandalone: true, selector: "ngx-stripe-card-group,[ngxStripeCardGroup]", inputs: { elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { elements: "elements", load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngx-stripe-card-group,[ngxStripeCardGroup]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: StripeElementsService }]; }, propDecorators: { elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], elements: [{
                type: Output
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeCardNumberComponent {
    constructor(stripeElementsService, cardGroup) {
        this.stripeElementsService = stripeElementsService;
        this.cardGroup = cardGroup;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes.options || changes.containerClass) {
                this.setupElement('options');
            }
        });
    }
    ngOnInit() {
        if (this.cardGroup) {
            this.cardGroupSubscription = this.cardGroup.elements.subscribe((elements) => {
                this.elements = elements;
                this.setupElement('elements');
            });
        }
        else {
            throw new Error('StripeCardNumberComponent must have StripeCardGroupDirective parent');
        }
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.cardGroupSubscription) {
            this.cardGroupSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getCardNumber() {
        return this.element;
    }
    setupElement(source) {
        var _a;
        const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
        if (this.element && source === 'options') {
            this.update(options);
        }
        else if (this.elements && source === 'elements') {
            this.element = this.elements.create('cardNumber', options);
            this.element.on('change', (ev) => {
                var _a;
                this.change.emit(ev);
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.change.emit(ev);
            });
            this.element.on('blur', () => {
                var _a;
                this.blur.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.blur.emit();
            });
            this.element.on('focus', () => {
                var _a;
                this.focus.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.focus.emit();
            });
            this.element.on('ready', () => {
                var _a;
                this.ready.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.ready.emit();
            });
            this.element.on('escape', () => {
                var _a;
                this.escape.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.escape.emit();
            });
            this.element.mount(this.stripeElementRef.nativeElement);
            this.load.emit(this.element);
            (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.load.emit(this.element);
        }
    }
}
StripeCardNumberComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardNumberComponent, deps: [{ token: StripeElementsService }, { token: StripeCardGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeCardNumberComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeCardNumberComponent, isStandalone: true, selector: "ngx-stripe-card-number", inputs: { containerClass: "containerClass", options: "options" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardNumberComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-card-number',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeCardGroupDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeCardExpiryComponent {
    constructor(stripeElementsService, cardGroup) {
        this.stripeElementsService = stripeElementsService;
        this.cardGroup = cardGroup;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes.options || changes.containerClass) {
                this.setupElement('options');
            }
        });
    }
    ngOnInit() {
        if (this.cardGroup) {
            this.cardGroupSubscription = this.cardGroup.elements.subscribe((elements) => {
                this.elements = elements;
                this.setupElement('elements');
            });
        }
        else {
            throw new Error('StripeCardExpiryComponent must have StripeCardGroupDirective parent');
        }
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.cardGroupSubscription) {
            this.cardGroupSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getCardExpiry() {
        return this.element;
    }
    setupElement(source) {
        var _a;
        const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
        if (this.element && source === 'options') {
            this.update(options);
        }
        else if (this.elements && source === 'elements') {
            this.element = this.elements.create('cardExpiry', options);
            this.element.on('change', (ev) => {
                var _a;
                this.change.emit(ev);
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.change.emit(ev);
            });
            this.element.on('blur', () => {
                var _a;
                this.blur.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.blur.emit();
            });
            this.element.on('focus', () => {
                var _a;
                this.focus.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.focus.emit();
            });
            this.element.on('ready', () => {
                var _a;
                this.ready.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.ready.emit();
            });
            this.element.on('escape', () => {
                var _a;
                this.escape.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.escape.emit();
            });
            this.element.mount(this.stripeElementRef.nativeElement);
            this.load.emit(this.element);
            (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.load.emit(this.element);
        }
    }
}
StripeCardExpiryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardExpiryComponent, deps: [{ token: StripeElementsService }, { token: StripeCardGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeCardExpiryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeCardExpiryComponent, isStandalone: true, selector: "ngx-stripe-card-expiry", inputs: { containerClass: "containerClass", options: "options" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardExpiryComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-card-expiry',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeCardGroupDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeCardCvcComponent {
    constructor(stripeElementsService, cardGroup) {
        this.stripeElementsService = stripeElementsService;
        this.cardGroup = cardGroup;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes.options || changes.containerClass) {
                this.setupElement('options');
            }
        });
    }
    ngOnInit() {
        if (this.cardGroup) {
            this.cardGroupSubscription = this.cardGroup.elements.subscribe((elements) => {
                this.elements = elements;
                this.setupElement('elements');
            });
        }
        else {
            throw new Error('StripeCardCvcComponent must have StripeCardGroupDirective parent');
        }
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.cardGroupSubscription) {
            this.cardGroupSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getCardCvc() {
        return this.element;
    }
    setupElement(source) {
        var _a;
        const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
        if (this.element && source === 'options') {
            this.update(options);
        }
        else if (this.elements && source === 'elements') {
            this.element = this.elements.create('cardCvc', options);
            this.element.on('change', (ev) => {
                var _a;
                this.change.emit(ev);
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.change.emit(ev);
            });
            this.element.on('blur', () => {
                var _a;
                this.blur.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.blur.emit();
            });
            this.element.on('focus', () => {
                var _a;
                this.focus.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.focus.emit();
            });
            this.element.on('ready', () => {
                var _a;
                this.ready.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.ready.emit();
            });
            this.element.on('escape', () => {
                var _a;
                this.escape.emit();
                (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.escape.emit();
            });
            this.element.mount(this.stripeElementRef.nativeElement);
            this.load.emit(this.element);
            (_a = this.cardGroup) === null || _a === void 0 ? void 0 : _a.load.emit(this.element);
        }
    }
}
StripeCardCvcComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardCvcComponent, deps: [{ token: StripeElementsService }, { token: StripeCardGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeCardCvcComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeCardCvcComponent, isStandalone: true, selector: "ngx-stripe-card-cvc", inputs: { containerClass: "containerClass", options: "options" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeCardCvcComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-card-cvc',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container
        *ngIf="cardGroup && cardGroup.state !== 'ready' && loadingTemplate"
        [ngTemplateOutlet]="loadingTemplate"
      ></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeCardGroupDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeEpsBankComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getEpsBankelement() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('epsBank', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeEpsBankComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeEpsBankComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeEpsBankComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeEpsBankComponent, isStandalone: true, selector: "ngx-stripe-eps-bank", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeEpsBankComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-eps-bank',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeFpxBankComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getFpxBank() {
        return this.element;
    }
    createElement(options = { accountHolderType: 'individual' }) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('fpxBank', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeFpxBankComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeFpxBankComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeFpxBankComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeFpxBankComponent, isStandalone: true, selector: "ngx-stripe-fpx-bank", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeFpxBankComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-fpx-bank',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeIbanComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getIban() {
        return this.element;
    }
    createElement(options = {}) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('iban', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIbanComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIbanComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIbanComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIbanComponent, isStandalone: true, selector: "ngx-stripe-iban", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIbanComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-iban',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeIdealBankComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getIdealBank() {
        return this.element;
    }
    createElement(options = {}) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('idealBank', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIdealBankComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIdealBankComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIdealBankComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIdealBankComponent, isStandalone: true, selector: "ngx-stripe-ideal-bank", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIdealBankComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-ideal-bank',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeIssuingCardCvcDisplayComponent {
    constructor(cdr, stripeElementsService, elementsProvider) {
        this.cdr = cdr;
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    createElement(options) {
        this.state = 'ready';
        this.cdr.detectChanges();
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('issuingCardCvcDisplay', options);
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIssuingCardCvcDisplayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardCvcDisplayComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIssuingCardCvcDisplayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIssuingCardCvcDisplayComponent, isStandalone: true, selector: "ngx-stripe-issuing-card-cvc-display", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardCvcDisplayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-issuing-card-cvc-display',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }] } });

class StripeIssuingCardExpiryDisplayComponent {
    constructor(cdr, stripeElementsService, elementsProvider) {
        this.cdr = cdr;
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    createElement(options) {
        this.state = 'ready';
        this.cdr.detectChanges();
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('issuingCardExpiryDisplay', options);
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIssuingCardExpiryDisplayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardExpiryDisplayComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIssuingCardExpiryDisplayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIssuingCardExpiryDisplayComponent, isStandalone: true, selector: "ngx-stripe-issuing-card-expiry-display", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardExpiryDisplayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-issuing-card-expiry-display',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }] } });

class StripeIssuingCardNumberDisplayComponent {
    constructor(cdr, stripeElementsService, elementsProvider) {
        this.cdr = cdr;
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    createElement(options) {
        this.state = 'ready';
        this.cdr.detectChanges();
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('issuingCardNumberDisplay', options);
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIssuingCardNumberDisplayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardNumberDisplayComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIssuingCardNumberDisplayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIssuingCardNumberDisplayComponent, isStandalone: true, selector: "ngx-stripe-issuing-card-number-display", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardNumberDisplayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-issuing-card-number-display',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }] } });

class StripeIssuingCardPinDisplayComponent {
    constructor(cdr, stripeElementsService, elementsProvider) {
        this.cdr = cdr;
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    createElement(options) {
        this.state = 'ready';
        this.cdr.detectChanges();
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('issuingCardPinDisplay', options);
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeIssuingCardPinDisplayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardPinDisplayComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeIssuingCardPinDisplayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeIssuingCardPinDisplayComponent, isStandalone: true, selector: "ngx-stripe-issuing-card-pin-display", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeIssuingCardPinDisplayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-issuing-card-pin-display',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }] } });

class StripeLinkAuthenticationComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.loaderror = new EventEmitter();
        this.loaderstart = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    /**
     * @deprecated
     */
    getLinkAuthenticationElement() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('linkAuthentication', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.on('loaderror', () => this.loaderror.emit());
        this.element.on('loaderstart', () => this.loaderstart.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeLinkAuthenticationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeLinkAuthenticationComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeLinkAuthenticationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeLinkAuthenticationComponent, isStandalone: true, selector: "ngx-stripe-link-authentication", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape", loaderror: "loaderror", loaderstart: "loaderstart" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeLinkAuthenticationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-link-authentication',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }], loaderror: [{
                type: Output
            }], loaderstart: [{
                type: Output
            }] } });

class StripeP24BankComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getP24Bankelement() {
        return this.element;
    }
    createElement(options) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('p24Bank', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeP24BankComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeP24BankComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeP24BankComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeP24BankComponent, isStandalone: true, selector: "ngx-stripe-p24-bank", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeP24BankComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-p24-bank',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripeAuBankAccountComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        this.element.update(options);
    }
    /**
     * @deprecated
     */
    getAuBankAccount() {
        return this.element;
    }
    createElement(options = {}) {
        if (this.element) {
            this.element.unmount();
        }
        this.element = this.elements.create('auBankAccount', options);
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', () => this.blur.emit());
        this.element.on('focus', () => this.focus.emit());
        this.element.on('ready', () => this.ready.emit());
        this.element.on('escape', () => this.escape.emit());
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripeAuBankAccountComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAuBankAccountComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripeAuBankAccountComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripeAuBankAccountComponent, isStandalone: true, selector: "ngx-stripe-au-bank-account", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape" }, queries: [{ propertyName: "loadingTemplate", first: true, predicate: NgxStripeElementLoadingTemplateDirective, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeAuBankAccountComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-au-bank-account',
                    standalone: true,
                    template: `
    <div class="field" #stripeElementRef>
      <ng-container *ngIf="state !== 'ready' && loadingTemplate" [ngTemplateOutlet]="loadingTemplate"></ng-container>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { loadingTemplate: [{
                type: ContentChild,
                args: [NgxStripeElementLoadingTemplateDirective, { read: TemplateRef }]
            }], stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }] } });

class StripePaymentElementComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.doNotCreateUntilClientSecretIsSet = false;
        this.load = new EventEmitter();
        this.blur = new EventEmitter();
        this.change = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.escape = new EventEmitter();
        this.loaderror = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = 'starting';
            let updateElements = false;
            if (!this.elementsProvider &&
                (changes.elementsOptions || changes.stripe || changes.clientSecret || changes.appearance || !this.elements)) {
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, Object.assign(Object.assign(Object.assign({}, (this.elementsOptions || {})), (this.appearance ? { appearance: this.appearance } : {})), (this.clientSecret ? { clientSecret: this.clientSecret } : {}))));
                updateElements = true;
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
            this.state = 'ready';
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, Object.assign(Object.assign(Object.assign({}, (this.elementsOptions || {})), (this.appearance ? { appearance: this.appearance } : {})), (this.clientSecret ? { clientSecret: this.clientSecret } : {}))));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    update(options) {
        return this.element.update(options);
    }
    collapse() {
        return this.element.collapse();
    }
    fetchUpdates() {
        return from(this.elements.fetchUpdates());
    }
    createElement(options = {}) {
        if (this.element) {
            this.element.unmount();
        }
        try {
            this.element = this.elements.create('payment', options);
        }
        catch (err) {
            this.elements = null;
            throw err;
        }
        this.element.on('change', (ev) => this.change.emit(ev));
        this.element.on('blur', (ev) => this.blur.emit(ev));
        this.element.on('focus', (ev) => this.focus.emit(ev));
        this.element.on('ready', (ev) => this.ready.emit(ev));
        this.element.on('escape', (ev) => this.escape.emit(ev));
        this.element.on('loaderror', (ev) => this.loaderror.emit(ev));
        this.element.mount(this.stripeElementRef.nativeElement);
        this.load.emit(this.element);
    }
}
StripePaymentElementComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripePaymentElementComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripePaymentElementComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripePaymentElementComponent, isStandalone: true, selector: "ngx-stripe-payment", inputs: { containerClass: "containerClass", options: "options", elementsOptions: "elementsOptions", stripe: "stripe", appearance: "appearance", clientSecret: "clientSecret", doNotCreateUntilClientSecretIsSet: "doNotCreateUntilClientSecretIsSet" }, outputs: { load: "load", blur: "blur", change: "change", focus: "focus", ready: "ready", escape: "escape", loaderror: "loaderror" }, viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `<div class="field" #stripeElementRef></div>`, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripePaymentElementComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-payment',
                    standalone: true,
                    template: `<div class="field" #stripeElementRef></div>`,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], appearance: [{
                type: Input
            }], clientSecret: [{
                type: Input
            }], doNotCreateUntilClientSecretIsSet: [{
                type: Input
            }], load: [{
                type: Output
            }], blur: [{
                type: Output
            }], change: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], escape: [{
                type: Output
            }], loaderror: [{
                type: Output
            }] } });

class StripePaymentRequestButtonComponent {
    constructor(stripeElementsService, elementsProvider) {
        this.stripeElementsService = stripeElementsService;
        this.elementsProvider = elementsProvider;
        this.load = new EventEmitter();
        this.change = new EventEmitter();
        this.blur = new EventEmitter();
        this.focus = new EventEmitter();
        this.ready = new EventEmitter();
        this.token = new EventEmitter();
        this.paymentMethod = new EventEmitter();
        this.source = new EventEmitter();
        this.cancel = new EventEmitter();
        this.shippingaddresschange = new EventEmitter();
        this.shippingoptionchange = new EventEmitter();
        this.notavailable = new EventEmitter();
        this.state = 'notready';
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            let updateElements = false;
            if (!this.elementsProvider && (changes.elementsOptions || changes.stripe || !this.elements)) {
                const elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe, this.elementsOptions));
                this.elements = elements;
                updateElements = true;
            }
            if (changes.paymentOptions && this.paymentRequest) {
                this.updateRequest(this.paymentOptions);
            }
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (changes.options || changes.containerClass || !this.element || updateElements) {
                if (this.element && !updateElements) {
                    this.update(options);
                }
                else if (this.elements && updateElements) {
                    this.createElement(options);
                }
            }
        });
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.stripeElementsService.mergeOptions(this.options, this.containerClass);
            if (this.elementsProvider) {
                this.elementsSubscription = this.elementsProvider.elements.subscribe((elements) => {
                    this.elements = elements;
                    this.createElement(options);
                    this.state = 'ready';
                });
            }
            else if (this.state === 'notready') {
                this.state = 'starting';
                this.elements = yield lastValueFrom(this.stripeElementsService.elements(this.stripe));
                this.createElement(options);
                this.state = 'ready';
            }
        });
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.destroy();
        }
        if (this.elementsSubscription) {
            this.elementsSubscription.unsubscribe();
        }
    }
    canMakePayment() {
        return from(this.paymentRequest.canMakePayment());
    }
    update(options) {
        this.element.update(options);
    }
    updateRequest(options) {
        const { currency, total, displayItems, shippingOptions } = options;
        this.paymentRequest.update({
            currency,
            total,
            displayItems,
            shippingOptions
        });
    }
    show() {
        this.paymentRequest.show();
    }
    abort() {
        this.paymentRequest.abort();
    }
    isShowing() {
        return this.paymentRequest.isShowing();
    }
    /**
     * @deprecated
     */
    getButton() {
        return this.element;
    }
    createElement(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.paymentRequest = this.stripeElementsService.paymentRequest(this.stripe, this.paymentOptions);
            this.paymentRequest.on('token', (ev) => this.token.emit(ev));
            if (this.paymentMethod.observed)
                this.paymentRequest.on('paymentmethod', (ev) => this.paymentMethod.emit(ev));
            if (this.source.observed && !this.paymentMethod.observed)
                this.paymentRequest.on('source', (ev) => this.source.emit(ev));
            this.paymentRequest.on('cancel', () => this.cancel.emit());
            this.paymentRequest.on('shippingaddresschange', (ev) => this.shippingaddresschange.emit(ev));
            this.paymentRequest.on('shippingoptionchange', (ev) => this.shippingoptionchange.emit(ev));
            if (this.element) {
                this.element.unmount();
            }
            this.element = this.elements.create('paymentRequestButton', Object.assign({ paymentRequest: this.paymentRequest }, options));
            const result = yield this.paymentRequest.canMakePayment();
            if (result) {
                this.element.on('click', (ev) => this.change.emit(ev));
                this.element.on('blur', () => this.blur.emit());
                this.element.on('focus', () => this.focus.emit());
                this.element.on('ready', () => this.ready.emit());
                this.element.mount(this.stripeElementRef.nativeElement);
                this.load.emit({
                    paymentRequestButton: this.element,
                    paymentRequest: this.paymentRequest
                });
            }
            else {
                this.notavailable.emit();
            }
        });
    }
}
StripePaymentRequestButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripePaymentRequestButtonComponent, deps: [{ token: StripeElementsService }, { token: StripeElementsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
StripePaymentRequestButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.0", type: StripePaymentRequestButtonComponent, isStandalone: true, selector: "ngx-stripe-payment-request-button", inputs: { containerClass: "containerClass", paymentOptions: "paymentOptions", options: "options", elementsOptions: "elementsOptions", stripe: "stripe" }, outputs: { load: "load", change: "change", blur: "blur", focus: "focus", ready: "ready", token: "token", paymentMethod: "paymentMethod", source: "source", cancel: "cancel", shippingaddresschange: "shippingaddresschange", shippingoptionchange: "shippingoptionchange", notavailable: "notavailable" }, viewQueries: [{ propertyName: "stripeElementRef", first: true, predicate: ["stripeElementRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `<div class="field" #stripeElementRef></div>`, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripePaymentRequestButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-stripe-payment-request-button',
                    standalone: true,
                    template: `<div class="field" #stripeElementRef></div>`,
                    imports: [CommonModule]
                }]
        }], ctorParameters: function () {
        return [{ type: StripeElementsService }, { type: StripeElementsDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { stripeElementRef: [{
                type: ViewChild,
                args: ['stripeElementRef']
            }], containerClass: [{
                type: Input
            }], paymentOptions: [{
                type: Input
            }], options: [{
                type: Input
            }], elementsOptions: [{
                type: Input
            }], stripe: [{
                type: Input
            }], load: [{
                type: Output
            }], change: [{
                type: Output
            }], blur: [{
                type: Output
            }], focus: [{
                type: Output
            }], ready: [{
                type: Output
            }], token: [{
                type: Output
            }], paymentMethod: [{
                type: Output
            }], source: [{
                type: Output
            }], cancel: [{
                type: Output
            }], shippingaddresschange: [{
                type: Output
            }], shippingoptionchange: [{
                type: Output
            }], notavailable: [{
                type: Output
            }] } });

class StripeFactoryService {
    constructor(version, baseKey, baseOptions, loader, window) {
        this.version = version;
        this.baseKey = baseKey;
        this.baseOptions = baseOptions;
        this.loader = loader;
        this.window = window;
    }
    create(key, options) {
        if (!key && !this.baseKey) {
            throw new Error('No key defined! Either you need to pass it as a parameter or define it when you call NgxStripeModule.forRoot()');
        }
        return new StripeInstance(this.version, this.loader, this.window, key || this.baseKey, options || this.baseOptions);
    }
}
StripeFactoryService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeFactoryService, deps: [{ token: NGX_STRIPE_VERSION }, { token: STRIPE_PUBLISHABLE_KEY }, { token: STRIPE_OPTIONS }, { token: LazyStripeAPILoader }, { token: WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
StripeFactoryService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeFactoryService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: StripeFactoryService, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [NGX_STRIPE_VERSION]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [STRIPE_PUBLISHABLE_KEY]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [STRIPE_OPTIONS]
                    }] }, { type: LazyStripeAPILoader }, { type: WindowRef }];
    } });

const components = [
    StripeAddressComponent,
    StripeAffirmMessageComponent,
    StripeAfterpayClearpayMessageComponent,
    StripeCardComponent,
    StripeCardNumberComponent,
    StripeCardExpiryComponent,
    StripeCardCvcComponent,
    StripeEpsBankComponent,
    StripeFpxBankComponent,
    StripeIbanComponent,
    StripeIdealBankComponent,
    StripeIssuingCardCvcDisplayComponent,
    StripeIssuingCardExpiryDisplayComponent,
    StripeIssuingCardNumberDisplayComponent,
    StripeIssuingCardPinDisplayComponent,
    StripeLinkAuthenticationComponent,
    StripeP24BankComponent,
    StripeAuBankAccountComponent,
    StripePaymentElementComponent,
    StripePaymentRequestButtonComponent
];
const directives = [StripeCardGroupDirective, StripeElementsDirective, NgxStripeElementLoadingTemplateDirective];
const currentVersion = '15.4.4';
class NgxStripeModule {
    static forRoot(publishableKey, options) {
        return {
            ngModule: NgxStripeModule,
            providers: [
                LazyStripeAPILoader,
                StripeService,
                StripeFactoryService,
                StripeElementsService,
                WindowRef,
                DocumentRef,
                {
                    provide: STRIPE_PUBLISHABLE_KEY,
                    useValue: publishableKey
                },
                {
                    provide: STRIPE_OPTIONS,
                    useValue: options
                },
                {
                    provide: NGX_STRIPE_VERSION,
                    useValue: currentVersion
                }
            ]
        };
    }
    static forChild(publishableKey, options) {
        return {
            ngModule: NgxStripeModule,
            providers: [
                LazyStripeAPILoader,
                StripeService,
                StripeFactoryService,
                StripeElementsService,
                WindowRef,
                DocumentRef,
                {
                    provide: STRIPE_PUBLISHABLE_KEY,
                    useValue: publishableKey
                },
                {
                    provide: STRIPE_OPTIONS,
                    useValue: options
                },
                {
                    provide: NGX_STRIPE_VERSION,
                    useValue: currentVersion
                }
            ]
        };
    }
}
NgxStripeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxStripeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeModule, imports: [CommonModule, StripeAddressComponent,
        StripeAffirmMessageComponent,
        StripeAfterpayClearpayMessageComponent,
        StripeCardComponent,
        StripeCardNumberComponent,
        StripeCardExpiryComponent,
        StripeCardCvcComponent,
        StripeEpsBankComponent,
        StripeFpxBankComponent,
        StripeIbanComponent,
        StripeIdealBankComponent,
        StripeIssuingCardCvcDisplayComponent,
        StripeIssuingCardExpiryDisplayComponent,
        StripeIssuingCardNumberDisplayComponent,
        StripeIssuingCardPinDisplayComponent,
        StripeLinkAuthenticationComponent,
        StripeP24BankComponent,
        StripeAuBankAccountComponent,
        StripePaymentElementComponent,
        StripePaymentRequestButtonComponent, StripeCardGroupDirective, StripeElementsDirective, NgxStripeElementLoadingTemplateDirective], exports: [StripeAddressComponent,
        StripeAffirmMessageComponent,
        StripeAfterpayClearpayMessageComponent,
        StripeCardComponent,
        StripeCardNumberComponent,
        StripeCardExpiryComponent,
        StripeCardCvcComponent,
        StripeEpsBankComponent,
        StripeFpxBankComponent,
        StripeIbanComponent,
        StripeIdealBankComponent,
        StripeIssuingCardCvcDisplayComponent,
        StripeIssuingCardExpiryDisplayComponent,
        StripeIssuingCardNumberDisplayComponent,
        StripeIssuingCardPinDisplayComponent,
        StripeLinkAuthenticationComponent,
        StripeP24BankComponent,
        StripeAuBankAccountComponent,
        StripePaymentElementComponent,
        StripePaymentRequestButtonComponent, StripeCardGroupDirective, StripeElementsDirective, NgxStripeElementLoadingTemplateDirective] });
NgxStripeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeModule, imports: [CommonModule, components] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: NgxStripeModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...components, ...directives],
                    imports: [CommonModule, ...components, ...directives]
                }]
        }] });

function injectStripe(publishableKey, options) {
    if (publishableKey) {
        const factory = inject(StripeFactoryService);
        return factory.create(publishableKey, options);
    }
    else if (inject(STRIPE_PUBLISHABLE_KEY)) {
        return inject(StripeService);
    }
    throw new Error('Publishable Key is required either global or pass as parameter');
}

/*
 * Public API Surface of ngx-stripe
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DocumentRef, LazyStripeAPILoader, NGX_STRIPE_VERSION, NgxStripeElementLoadingTemplateDirective, NgxStripeModule, STRIPE_OPTIONS, STRIPE_PUBLISHABLE_KEY, StripeAddressComponent, StripeAffirmMessageComponent, StripeAfterpayClearpayMessageComponent, StripeAuBankAccountComponent, StripeCardComponent, StripeCardCvcComponent, StripeCardExpiryComponent, StripeCardGroupDirective, StripeCardNumberComponent, StripeElementsDirective, StripeElementsService, StripeEpsBankComponent, StripeFactoryService, StripeFpxBankComponent, StripeIbanComponent, StripeIdealBankComponent, StripeInstance, StripeIssuingCardCvcDisplayComponent, StripeIssuingCardExpiryDisplayComponent, StripeIssuingCardNumberDisplayComponent, StripeIssuingCardPinDisplayComponent, StripeLinkAuthenticationComponent, StripeP24BankComponent, StripePaymentElementComponent, StripePaymentRequestButtonComponent, StripeService, WindowRef, injectStripe };
//# sourceMappingURL=ngx-stripe.mjs.map
